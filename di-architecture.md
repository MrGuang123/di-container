# DI 容器架构与流程图

## 📐 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         DI 容器系统                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐      ┌──────────────┐      ┌──────────────┐ │
│  │  Container   │◄─────│ ContainerModule│    │  Decorators  │ │
│  │   (核心)     │      │   (模块化)    │      │  (@Inject)   │ │
│  └──────┬───────┘      └──────────────┘      └──────────────┘ │
│         │                                                       │
│         │ 管理                                                  │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              Provider 注册表                             │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │  │
│  │  │ClassProvider │  │ValueProvider │  │FactoryProvider│ │  │
│  │  │              │  │              │  │              │  │  │
│  │  │ useClass     │  │  useValue    │  │  useFactory  │  │  │
│  │  │ + inject[]   │  │              │  │  + deps[]    │  │  │
│  │  └──────────────┘  └──────────────┘  └──────────────┘  │  │
│  └─────────────────────────────────────────────────────────┘  │
│         │                                                       │
│         │ 解析依赖                                              │
│         ▼                                                       │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              实例缓存层                                   │  │
│  │  ┌──────────────────────┐  ┌──────────────────────┐    │  │
│  │  │  Singleton Cache     │  │   Transient          │    │  │
│  │  │  (单例缓存)          │  │   (每次创建新实例)    │    │  │
│  │  └──────────────────────┘  └──────────────────────┘    │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 依赖解析流程图

```
                    开始解析 resolve(Token)
                            │
                            ▼
                  ┌─────────────────────┐
                  │ 检查循环依赖         │
                  │ (stack 中是否有此 Token)│
                  └──────────┬──────────┘
                             │
                    ┌────────┴────────┐
                    │                 │
                   是                否
                    │                 │
                    ▼                 ▼
            ┌──────────────┐   ┌─────────────────┐
            │ 抛出循环依赖  │   │ 查找 Provider    │
            │ 错误         │   │ (自身 -> 父容器) │
            └──────────────┘   └────────┬─────────┘
                                        │
                               ┌────────┴────────┐
                               │                 │
                           找到了            找不到
                               │                 │
                               ▼                 ▼
                     ┌──────────────┐    ┌──────────────┐
                     │ 检查作用域    │    │ 抛出 Not Found│
                     │ Scope?       │    │ 错误         │
                     └──────┬───────┘    └──────────────┘
                            │
                  ┌─────────┴─────────┐
                  │                   │
            Singleton            Transient
                  │                   │
                  ▼                   │
        ┌──────────────────┐          │
        │ 缓存中是否已存在？│          │
        └─────────┬────────┘          │
                  │                   │
         ┌────────┴────────┐          │
         │                 │          │
        是                否          │
         │                 │          │
         ▼                 │          │
   ┌──────────┐            │          │
   │ 返回缓存  │            │          │
   │ 实例     │            │          │
   └──────────┘            │          │
                           │          │
                           ▼          ▼
                    ┌──────────────────────┐
                    │  实例化 instantiate() │
                    └──────────┬───────────┘
                               │
              ┌────────────────┼────────────────┐
              │                │                │
              ▼                ▼                ▼
      ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
      │ClassProvider│  │ValueProvider│  │FactoryProvider│
      │             │  │             │  │             │
      │ 1.获取inject│  │ 直接返回    │  │ 1.解析 deps │
      │ 2.递归解析  │  │ useValue    │  │ 2.调用      │
      │ 3.new Ctor  │  │             │  │   useFactory│
      └──────┬──────┘  └──────┬──────┘  └──────┬──────┘
             │                │                │
             └────────────────┼────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │ 属性注入          │
                    │ applyPropertyInjections()│
                    │ (处理 @Inject 装饰器)│
                    └──────────┬─────────┘
                               │
                               ▼
                    ┌──────────────────┐
                    │ 生命周期钩子      │
                    │ onInit()         │
                    └──────────┬─────────┘
                               │
                               ▼
                  ┌─────────────────────┐
                  │ Singleton?          │
                  └──────────┬──────────┘
                             │
                    ┌────────┴────────┐
                    │                 │
                   是                否
                    │                 │
                    ▼                 │
            ┌──────────────┐          │
            │ 保存到缓存    │          │
            │ singletons   │          │
            └──────┬───────┘          │
                   │                 │
                   └────────┬────────┘
                            │
                            ▼
                      返回实例
```

## 🏗️ 三种 Provider 类型详解

```
┌─────────────────────────────────────────────────────────────┐
│                      Provider 类型                           │
└─────────────────────────────────────────────────────────────┘

1️⃣ ClassProvider (类提供者)
   ┌──────────────────────────────────────┐
   │ {                                    │
   │   token: TOKENS.Logger,              │
   │   useClass: ConsoleLogger,           │──┐
   │   scope: Scope.Singleton             │  │
   │ }                                    │  │
   └──────────────────────────────────────┘  │
                                              │
   使用场景：注册服务类                        │
   实例化方式：new useClass(...deps)          │
   依赖声明：static inject = [token1, ...]   │
                                              │
                                              │
2️⃣ ValueProvider (值提供者)                   │
   ┌──────────────────────────────────────┐  │
   │ {                                    │  │
   │   token: TOKENS.Config,              │  │
   │   useValue: { appName: "MyApp" }     │──┤
   │ }                                    │  │
   └──────────────────────────────────────┘  │
                                              │
   使用场景：配置对象、常量                    │
   实例化方式：直接返回 useValue               │
   依赖声明：无                               │
                                              │
                                              │
3️⃣ FactoryProvider (工厂提供者)               │
   ┌──────────────────────────────────────┐  │
   │ {                                    │  │
   │   token: TOKENS.Database,            │  │
   │   useFactory: (cfg) => new DB(cfg),  │──┘
   │   deps: [TOKENS.Config],             │
   │   scope: Scope.Singleton             │
   │ }                                    │
   └──────────────────────────────────────┘
   
   使用场景：需要复杂初始化逻辑
   实例化方式：useFactory(...resolvedDeps)
   依赖声明：deps 数组
```

## 🎯 依赖注入方式对比

```
┌─────────────────────────────────────────────────────────────┐
│                   依赖注入方式                               │
└─────────────────────────────────────────────────────────────┘

方式一：构造器注入 (Constructor Injection)
┌────────────────────────────────────────────────────────┐
│ class Greeter {                                        │
│   static inject = [TOKENS.Logger, TOKENS.Config];     │
│   constructor(                                         │
│     private logger: Logger,                            │
│     private config: Config                             │
│   ) {}                                                 │
│ }                                                      │
└────────────────────────────────────────────────────────┘
   ✅ 优点：依赖明确、类型安全、易于测试
   ⚠️  注意：需要声明 static inject 数组


方式二：属性注入 (Property Injection)
┌────────────────────────────────────────────────────────┐
│ class Greeter {                                        │
│   @Inject(TOKENS.Logger)                               │
│   private logger!: Logger;                             │
│                                                        │
│   @Inject(TOKENS.Config)                               │
│   private config!: Config;                             │
│ }                                                      │
└────────────────────────────────────────────────────────┘
   ✅ 优点：灵活、可选依赖
   ⚠️  注意：在 onInit() 后才可用
```

## 🌳 容器层级结构

```
                    ┌──────────────────┐
                    │   Root Container │
                    │                  │
                    │ providers: Map   │
                    │ singletons: Map  │
                    └────────┬─────────┘
                             │
                   parent 引用│
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
      ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
      │Child Container│Child Container│Child Container│
      │              │ │              │ │              │
      │providers: Map│ │providers: Map│ │providers: Map│
      │singletons:Map│ │singletons:Map│ │singletons:Map│
      └─────────────┘ └─────────────┘ └─────────────┘

特点：
• 子容器继承父容器的 Provider 定义
• 子容器有独立的 Singleton 缓存
• 查找 Provider：先查自身，再查父容器
• 实例缓存：只在当前容器
```

## 🔁 循环依赖检测机制

```
假设有循环依赖：A → B → C → A

resolve(A, [])
  │
  ├─ stack: [A]
  │  resolve(B, [A])
  │    │
  │    ├─ stack: [A, B]
  │    │  resolve(C, [A, B])
  │    │    │
  │    │    ├─ stack: [A, B, C]
  │    │    │  resolve(A, [A, B, C])
  │    │    │    │
  │    │    │    └─ ❌ A 在 stack 中！
  │    │    │       抛出 CircularDependencyError
  │    │    │       路径：A -> B -> C -> A
```

## ⚙️ 完整使用流程示例

```
第1步：定义 Tokens
┌────────────────────────────────┐
│ const TOKENS = {               │
│   Logger: Symbol("Logger"),    │
│   Config: Symbol("Config")     │
│ }                              │
└────────────────────────────────┘

第2步：定义服务类
┌────────────────────────────────┐
│ class ConsoleLogger {          │
│   log(msg: string) {...}       │
│ }                              │
│                                │
│ class Greeter {                │
│   static inject = [            │
│     TOKENS.Logger,             │
│     TOKENS.Config              │
│   ];                           │
│   constructor(                 │
│     private logger,            │
│     private config             │
│   ) {}                         │
│ }                              │
└────────────────────────────────┘

第3步：注册 Provider
┌────────────────────────────────┐
│ const container = new Container();│
│                                │
│ container.register(            │
│   {                            │
│     token: TOKENS.Logger,      │
│     useClass: ConsoleLogger    │
│   },                           │
│   {                            │
│     token: TOKENS.Config,      │
│     useValue: { app: "MyApp" } │
│   },                           │
│   {                            │
│     token: Greeter,            │
│     useClass: Greeter          │
│   }                            │
│ );                             │
└────────────────────────────────┘

第4步：解析依赖
┌────────────────────────────────┐
│ const greeter =                │
│   container.resolve(Greeter);  │
│                                │
│ // 自动注入：                   │
│ // 1. Logger 实例              │
│ // 2. Config 对象              │
│ // 3. 调用 onInit()            │
└────────────────────────────────┘
```

## 📊 核心数据结构

```
Container 类：
┌──────────────────────────────────────┐
│ class Container {                    │
│   private providers: Map<Token, Provider>  // Provider 定义
│   private singletons: Map<Token, any>      // 单例缓存
│   private parent?: Container               // 父容器引用
│                                      │
│   register(...providers)             │  // 注册
│   resolve<T>(token): T               │  // 解析
│   createChild(): Container           │  // 创建子容器
│ }                                    │
└──────────────────────────────────────┘

propertyInjections (全局 WeakMap)：
┌──────────────────────────────────────┐
│ WeakMap<                             │
│   Constructor,                       │
│   Array<{                            │
│     key: string | symbol,            │
│     token: Token                     │
│   }>                                 │
│ >                                    │
└──────────────────────────────────────┘
存储：类 -> 属性注入元数据
```

## 🎓 关键概念总结

| 概念 | 说明 | 示例 |
|------|------|------|
| **Token** | 依赖的唯一标识 | `Symbol("Logger")` 或类本身 |
| **Provider** | 描述如何创建实例 | `{ token, useClass }` |
| **Scope** | 实例生命周期 | `Singleton` / `Transient` |
| **Inject** | 属性注入装饰器 | `@Inject(TOKENS.Logger)` |
| **Container** | DI 容器核心 | 管理注册和解析 |
| **Module** | 模块化注册 | 批量注册 Provider |

## 💡 设计亮点

1. ✅ **无第三方依赖**：纯 TypeScript 实现
2. ✅ **类型安全**：完整的 TypeScript 类型定义
3. ✅ **循环依赖检测**：防止运行时错误
4. ✅ **多种注入方式**：构造器 + 属性注入
5. ✅ **层级容器**：支持作用域隔离
6. ✅ **生命周期钩子**：`onInit()` 初始化
7. ✅ **模块化**：`ContainerModule` 组织代码

